#!/bin/bash

export LIBVIRT_DEFAULT_URI=qemu:///system

function get_network_name() {
  local type=$1
  case "$type" in
    management)
      echo "rhosp13-mgmt"
      ;;
    provisioning)
      echo "rhosp13-prov"
      ;;
    *)
      return 1
  esac
}


function build_network_xml() {
  local type="$1"
  local nname="$2"
  local fname=`mktemp`
  local addr=$(get_network_ip $type)
  case "$type" in
    management)
      echo "<network><name>$nname</name><bridge name=\"$nname\" /><forward mode=\"nat\"/><ip address=\"$addr.1\" netmask=\"255.255.255.0\"/></network>" > $fname
      ;;
    provisioning)
      echo "<network><name>$nname</name><bridge name=\"$nname\" /><ip address=\"$addr.1\" netmask=\"255.255.255.0\"/></network>" > $fname
      ;;
    *)
      return 1
  esac
  echo $fname
}

function build_network_xml_dhcp() {
  local nname=$1
  local network=$2
  local brname=$3
  local dhcp=$4
  local forward=$5
  local fname=`mktemp`
  local net_base_ip=$(echo "$network" | cut -d '.' -f 1,2,3)
  local nic_ip_last=$(echo "$network" | cut -d '.' -f 4)
  if [[ -z "$nic_ip_last" || $"nic_ip_last" == '0' ]]; then
    nic_ip_last=1
  fi
  local nic_ip="${net_base_ip}.${nic_ip_last}"
  local dhcp_start="${net_base_ip}.100"
  local dhcp_end="${net_base_ip}.200"
  cat <<EOF > $fname
<network>
  <name>$nname</name>
  <bridge name="$brname"/>
EOF
  if  [[ "$forward" != "no_forward" ]] ; then
  cat <<EOF >> $fname
  <forward mode="$forward"/>
EOF
  fi
  cat <<EOF >> $fname
  <domain name='localdomain' localOnly='yes'/>
  <ip address="$nic_ip" netmask="255.255.255.0">
EOF
  if  [[ "$dhcp" == "yes" ]] ; then
  cat <<EOF >> $fname
    <dhcp>
      <range start="$dhcp_start" end="$dhcp_end"/>
    </dhcp>
EOF
  fi
  cat <<EOF >> $fname
  </ip>
</network>
EOF

  echo $fname
}

function delete_network() {
  local type="$1"
  local network_name=`get_network_name $type`
  virsh net-destroy $network_name 2> /dev/null || true
  virsh net-undefine $network_name 2> /dev/null || true
}

function create_network() {
  local type="$1"

  delete_network $type

  local network_name=`get_network_name $type`
  local fxml=`build_network_xml $type $network_name`
  virsh net-define $fxml
  rm $fxml
  virsh net-autostart $network_name
  virsh net-start $network_name
}

function delete_network_dhcp() {
  local network_name="$1"
  virsh net-destroy $network_name 2> /dev/null || true
  virsh net-undefine $network_name 2> /dev/null || true
}

function create_network_dhcp() {
  local network_name=$1
  local addr=$2
  local brname=$3
  local dhcp=${4:-'yes'}
  local forward=${5:-'nat'}
  local fxml=$(build_network_xml_dhcp $network_name $addr $brname $dhcp $forward)
  virsh net-define $fxml
  rm -f $fxml
  virsh net-autostart $network_name
  virsh net-start $network_name
}

function update_network_dhcp() {
  local net_name=$1
  local host=$2
  local mac=$3
  local ip=$4
  virsh net-update $net_name add ip-dhcp-host "<host mac='$mac' name='$host' ip='$ip' />"
}

function create_pool() {
  local poolname="$1"
  local path="/var/lib/libvirt/$poolname"
  if ! virsh pool-info $poolname &> /dev/null ; then
    virsh pool-define-as $poolname dir - - - - "$path"
    virsh pool-build $poolname
    virsh pool-start $poolname
    virsh pool-autostart $poolname
  fi
}

function get_pool_path() {
  local poolname=$1
  virsh pool-info $poolname &>/dev/null || return
  virsh pool-dumpxml $poolname | sed -n '/path/{s/.*<path>\(.*\)<\/path>.*/\1/;p}'
}

function create_volume() {
  local name=$1
  local poolname=$2
  local vm_disk_size=$3
  delete_volume $name.qcow2 $poolname
  local pool_path=$(get_pool_path $poolname)
  qemu-img create -f qcow2 -o preallocation=metadata $pool_path/$name.qcow2 $vm_disk_size 1>/dev/null
  echo $pool_path/$name.qcow2
}

function create_volume_from() {
  local vol=$1
  local pool=$2
  local src_vol=$3
  local src_pool=$4
  local vol_file=`mktemp`
  cat <<EOF > $vol_file
<volume type='file'>
  <name>$vol</name>
  <target>
    <format type='qcow2'/>
  </target>
</volume>
EOF
  virsh vol-create-from --pool $pool --file $vol_file --vol $src_vol --inputpool $src_pool 1>/dev/null
  local pool_path=$(get_pool_path $pool)
  echo $pool_path/$vol
}

function create_new_volume() {
  local vol=$1
  local pool=$2
  local size_gb=$3
  local vol_file=`mktemp`
  cat <<EOF > $vol_file
<volume type='file'>
  <name>$vol</name>
  <capacity unit='gb'>$size_gb</capacity>
  <target>
    <format type='qcow2'/>
    <permissions>
      <mode>0644</mode>
    </permissions>
  </target>
</volume>
EOF
  virsh vol-create --pool $pool --file $vol_file 1>/dev/null
  local pool_path=$(get_pool_path $pool)
  echo $pool_path/$vol
}

function define_machine() {
  # parameter net could be: netname1,netname2
  # or netname1/mac1,netname2/mac
  local name=$1
  local vcpus=$2
  local mem=$3
  local os=$4
  local net=$5
  local disk_path=$6
  shift 6
  NET_DRIVER=${NET_DRIVER:-'e1000'}
  local disk_opts="path=${disk_path},device=disk,cache=writeback,bus=virtio,format=qcow2"
  local net_opts=''
  local i=''
  for i in $(echo $net | tr ',' ' ') ; do
    local nname=$(echo $i | cut -d '/' -f 1)
    local mac=$(echo $i | cut -s -d '/' -f 2)
    net_opts+=" --network network=${nname},model=$NET_DRIVER"
    if [[ -n "$mac" ]] ; then
      net_opts+=",mac=${mac}"
    fi
  done
  local more_disks=''
  while (($# > 1)) ; do
    local path=$1 ; shift
    local size=${1:-60} ; shift
    more_disks+=" --disk path=${path},device=disk,cache=writeback,bus=virtio,format=qcow2,size=${size}"
  done
  virt-install --name $name \
    --ram $mem \
    --memorybacking hugepages=on \
    --vcpus $vcpus \
    --cpu host \
    --os-variant $os \
    --disk $disk_opts \
    $more_disks \
    $net_opts \
    --boot hd \
    --noautoconsole \
    --graphics vnc,listen=0.0.0.0 \
    --dry-run --print-xml > /tmp/oc-$name.xml
  virsh define --file /tmp/oc-$name.xml
}

function start_vm() {
  local name=$1
  virsh start $name --force-boot
}

function ensure_vbmcd(){
  if ! ps aux | grep -v grep | grep -q vbmcd ; then
    vbmcd
    sleep 5
  fi
}

function call_vbmc() {
  local cmd=$1
  shift
  local opts="$@"
  ensure_vbmcd
  vbmc $cmd --no-daemon $opts 
}

function delete_domain() {
  local name=$1
  if virsh dominfo $name 2>/dev/null ; then
    virsh destroy $name || true
    sleep 2
    virsh undefine $name || true
  fi
}

function delete_domains() {
  local domname=${1:-rhosp13-overcloud-}
  declare name
  for name in `virsh list --all | grep "$domname" | awk '{print $2}'` ; do
    delete_domain $name
  done

  delete_domain rhosp13-undercloud

  for name in $(call_vbmc list | grep "$domname" | awk '{print($2)}') ; do
    delete_vbmc $name
  done
}

function delete_volume() {
  local volname=$1
  local poolname=$2
  local pool_path=$(get_pool_path $poolname)
  virsh vol-delete $volname --pool $poolname 2>/dev/null || rm -f $pool_path/$volname 2>/dev/null
}


function _rhel_register() {
  local image_file=$1
  local ret=1
  local i=0
  while (( i < 5 )) ; do
    echo "Image registration try=$i"
    virt-customize -a $image_file \
      --sm-credentials ${RHEL_USER}:password:${RHEL_PASSWORD} --sm-register && ret=0
    if (( ret == 0 )) ; then
      break
    fi
    (( i+=1 ))
  done
  echo "Image registration result for $i tries: $ret"
  return $ret
}

function _rhel_attach() {
  local image_file=$1
  local attach_type='auto'
  if [[ -n "$RHEL_POOL_ID" ]] ; then
    attach_type="pool:${RHEL_POOL_ID}"
  fi
  local ret=1
  local i=0
  while (( i < 5 )) ; do
    echo "Subscription attach try=$i"
    virt-customize -a $image_file --sm-attach ${attach_type} && ret=0
    if (( ret == 0 )) ; then
      break
    fi
    (( i+=1 ))
  done
  echo "Subscription attach result for $i tries: $ret"
  return $ret
}

function _rhel_repos() {
  local image_file=$1
  local common_repos=$(rhel_get_repos_for_os)
  local enable_repos_opts=''
  for i in $common_repos ; do
    enable_repos_opts+=" --enable=${i}"
  done
  local ret=1
  local i=0
  while (( i < 5 )) ; do
    echo "Enable yum repos try=$i"
    virt-customize -a $image_file \
      --run-command "subscription-manager repos ${enable_repos_opts}" && ret=0
    if (( ret == 0 )) ; then
      break
    fi
    (( i+=1 ))
  done
  echo "Enable yum repos result for $i tries: $ret"
  return $ret
}

function rhel_customize() {
  local image_file=$1
  local image_type=$2
  local net_opts="--no-network"
  
  virt-customize -a $image_file $net_opts \
    --run-command 'xfs_growfs /' \
    --run-command 'systemctl enable sshd' \
    --run-command 'sed -i "s/PasswordAuthentication no/PasswordAuthentication yes/g" /etc/ssh/sshd_config' \
    --root-password password:$IPMI_PASSWORD \
    --selinux-relabel
      # --run-command 'sed -i "s/SELINUX=.*/SELINUX=disabled/g" /etc/selinux/config'

  if [[ "$image_type" == 'undercloud' ]] ; then

    virt-customize -a $image_file $net_opts \
      --run-command 'yum remove -y cloud-init'

  fi
}

function rhel_unregister_system() {
  local image_file=$1
  # TODO: disable network related actions like rhel registration
  # virt-customize doesnt work on 18.04 with network
  # https://bugs.launchpad.net/ubuntu/+source/libguestfs/+bug/1768085
  local net_opts="--no-network"
  if [[ -f $image_file ]] ; then
    virt-customize -a $image_file $net_opts \
      --run-command "subscription-manager unregister" || true
  fi
}


function assert_env_exists() {
  local name=$1
  if virsh list --all | grep -q "$name" ; then
    echo 'ERROR: environment present. please clean up first'
    virsh list --all | grep "$name"
    exit 1
  fi
}

function wait_dhcp() {
  local net=$1
  local count=${2:-1}
  local host=${3:-''}
  local max_iter=${4:-20}
  local iter=0
  local filter="ipv4"
  if [[ -n "$host" ]] ; then
    filter+=".*${host}"
  fi
  while true ; do
    local ips=( `virsh net-dhcp-leases $net | sed 1,2d | grep "$filter" | awk '{print($5)}' | cut -d '/' -f 1` )
    if (( ${#ips[@]} == count )) ; then
      echo "${ips[@]}"
      break
    fi
    if (( iter >= max_iter )) ; then
      echo "Failed to wait for $count ip addresses allocation via dhcp" >&2
      exit 1
    fi
    echo "Waiting for $count dhcp address requested... $iter" >&2
    sleep 30
    ((++iter))
  done
}

function wait_ssh() {
  local addr=$1
  local ssh_key=${2:-''}
  local max_iter=${3:-20}
  local iter=0
  local ssh_opts='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'
  if [[ -n "$ssh_key" ]] ; then
    ssh_opts+=" -i $ssh_key"
  fi
  truncate -s 0 ./tmp_file
  while ! scp $ssh_opts -B ./tmp_file root@${addr}:/tmp/tmp_file ; do
    if (( iter >= max_iter )) ; then
      echo "Could not connect to VM $addr"
      exit 1
    fi
    echo "Waiting for VM $addr..."
    sleep 30
    ((++iter))
  done
}

function get_ip_by_mac() {
  local net=$1
  local filter=$2
  virsh net-dhcp-leases $net | sed 1,2d | grep "$filter" | awk '{print($5)}' | cut -d '/' -f 1
}

function delete_vbmc() {
  local domain=$1
  call_vbmc stop  $domain || true
  sleep 2
  call_vbmc delete $domain || true
}

function start_vbmc() {
  local port=$1
  local domain=$2
  local ipmi_address=$3
  local ipmi_user=$4
  local ipmi_password=$5
  local i=''
  for i in {1..5} ; do
    call_vbmc add --port $port --address $ipmi_address \
      --username $ipmi_user --password $ipmi_password \
      $domain
    sleep 2
    local status=$(call_vbmc show -f value $domain | awk '/status /{print($2)}')
    [[ "$status" == 'running' ]] && break
    # try start 
    call_vbmc start $domain
    sleep 2
    status=$(call_vbmc show -f value $domain | awk '/status /{print($2)}')
    [[ "$status" == 'running' ]] && break
    sleep 2
    # delete and try re-create
    delete_vbmc $domain
  done
}
